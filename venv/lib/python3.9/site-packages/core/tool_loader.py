"""
Dynamically discovers and loads tools registered via entry points.
"""
import sys
from importlib import metadata
from typing import List, Dict, Callable

# A cache to store loaded tool instances
_tool_cache: Dict[str, object] = {}

def load_all_tools() -> Dict[str, Callable]:
    """
    Discovers all available tools from the 'langgraph_agent_builder.tools' entry point.
    Returns a dictionary mapping tool names to their loaded tool functions/classes.
    Caches the tools after the first load to avoid redundant discovery.
    """
    if _tool_cache:
        return _tool_cache

    # Python 3.10+ has a more direct way to select entry points by group.
    # This check ensures compatibility with older Python versions.
    if sys.version_info < (3, 10):
        entry_points = metadata.entry_points()
        if "langgraph_agent_builder.tools" in entry_points:
            tool_entry_points = entry_points["langgraph_agent_builder.tools"]
        else:
            tool_entry_points = []
    else:
        tool_entry_points = metadata.entry_points(group="langgraph_agent_builder.tools")

    for ep in tool_entry_points:
        try:
            _tool_cache[ep.name] = ep.load()
        except ImportError as e:
            # This makes the tool discoverable but will raise an error if used
            # without the proper extras installed.
            def missing_dependency_func(original_error=e, extra_name=ep.module.split('.')[2]):
                raise ImportError(
                    f"Tool '{ep.name}' is available but its dependencies are not installed. "
                    f"Please install them with: pip install '.[{extra_name}]'\n"
                    f"Original error: {original_error}"
                )
            _tool_cache[ep.name] = missing_dependency_func
            
    return _tool_cache

def get_tools(names: List[str]) -> List[Callable]:
    """
    Loads and returns a list of specific tools by their registered names.
    """
    all_tools = load_all_tools()
    
    selected_tools: List[Callable] = []
    missing_tools: List[str] = []

    for name in names:
        if name in all_tools:
            # Check if it's a "missing dependency" placeholder function
            tool_func = all_tools[name]
            # The check must first ensure __kwdefaults__ is not None
            if (tool_func.__kwdefaults__ is not None 
                and "original_error" in tool_func.__kwdefaults__):
                 # This will raise the helpful ImportError
                tool_func()
            selected_tools.append(tool_func)
        else:
            missing_tools.append(name)
            
    if missing_tools:
        raise ValueError(f"Tools not found: {', '.join(missing_tools)}. "
                         f"Available tools are: {list(all_tools.keys())}")
                         
    return selected_tools

def get_tool(name: str) -> Callable:
    """
    Loads and returns a single tool by its registered name.
    """
    all_tools = load_all_tools()
    if name not in all_tools:
        raise ValueError(f"Tool not found: '{name}'. "
                         f"Available tools are: {list(all_tools.keys())}")
    
    tool_func = all_tools[name]
    # Raise the ImportError if dependencies are missing
    if (tool_func.__kwdefaults__ is not None 
        and "original_error" in tool_func.__kwdefaults__):
        tool_func()

    return tool_func 