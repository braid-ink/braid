# Advanced Agent Architectures

To build truly complex and robust agents, you need to move beyond a single ReAct loop and adopt more sophisticated architectural patterns. This guide covers three powerful patterns: designing a structured "scratchpad" for your agent's state, the orchestrator/worker model, and implementing reflection/self-correction loops.

## 1. Designing an Agent "Scratchpad"

For complex tasks, an agent needs more than just a list of messages. It needs a structured "scratchpad" in its state to keep track of its plan, intermediate results, and other context. This is achieved by designing a more detailed `TypedDict` for your graph's state.

A well-designed state schema is the foundation of a complex agent.

### Example State Schema:

```python
from typing_extensions import TypedDict
from typing import List, Annotated
from langgraph.graph.message import add_messages

class ResearchAgentState(TypedDict):
    # The original user question
    question: str
    
    # The list of messages, annotated with a reducer to append new messages
    messages: Annotated[list, add_messages]
    
    # A list of URLs to research, generated by an initial planning step
    urls_to_research: List[str]
    
    # The results from researching each URL
    # This might be a list of strings, where each string is the content of a webpage
    research_results: List[str]
    
    # The final, synthesized report
    final_report: str
```

By structuring the state this way, each node in your graph has a clear purpose: one node might populate `urls_to_research`, a set of parallel nodes might populate `research_results`, and a final node would use `research_results` to generate the `final_report`.

## 2. The Orchestrator/Worker Pattern (Sub-graphs)

This is a powerful pattern for breaking down a complex task. You have a main "orchestrator" agent that delegates specific sub-tasks to specialized "worker" agents. These workers are themselves implemented as LangGraphs (sub-graphs).

-   **Orchestrator**: This is a high-level graph. Its job is to understand the user's request, create a plan, and route tasks to the appropriate workers. It might decide that a task requires research first, then data analysis, then writing.
-   **Workers**: These are focused sub-graphs that are experts at a single task (e.g., performing a web search, analyzing a dataset, writing code).

This pattern makes your agent more modular, easier to debug, and allows for the reuse of specialized components. You add a sub-graph to a parent graph as a node.

```python
# In the orchestrator graph builder
builder.add_node("research_worker", research_sub_graph)
```

## 3. Reflection and Self-Correction Loops

The most advanced agents can critique and improve their own work. This is achieved by adding a "reflection" step to your graph.

-   **Generate Initial Output**: A worker node produces an initial output (e.g., a draft of a report).
-   **Reflect on Output**: A new "reflection" node is added. This node takes the draft and prompts an LLM to critique it. The prompt might be something like: *"Review the following report. Is it complete? Does it fully answer the user's question? Are there any missing details? If so, what specific steps should be taken to improve it?"*
-   **Conditional Routing**: A conditional edge then checks the output of the reflection node.
    -   If the reflection LLM says the work is complete, the graph can `END`.
    -   If the reflection LLM suggests improvements, the edge can route back to the worker node (or another planning node) to incorporate the feedback and generate a revised draft.

This cyclical process of generating, reflecting, and refining allows the agent to produce much higher-quality output than a single-pass generation. It is a key pattern for building agents that can tackle complex, open-ended tasks. 